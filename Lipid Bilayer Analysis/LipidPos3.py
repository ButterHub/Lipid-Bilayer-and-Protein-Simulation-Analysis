# -*- coding: utf-8 -*-
#!/usr/bin/env python

"""Graphs generated by LipidPos:
G1_Full_Plane_Separate
G2_Half_Plane_SetSeparate
G3_Full_Set
G4_Frequency_vs_Position

Created on Tue Jul 18 09:08:20 2017 @author: Adrian Butterworth"""
import math, os #importing built in modules first.
# from __future__ import unicode literals #Could be used to type Angstroms unit directly.
import numpy as np #then import custom modules. 
from scipy import optimize
from scipy.optimize import curve_fit
import matplotlib as mpl, matplotlib.pyplot as plt #first comment specifies the encoding. 8-bit Unicode Transformation Format
#having PROBLEMS? make sure you have a copy of
#matplotlibrc file in the same folder.

#Ensuring graph folder is present.
if not os.path.exists("graphs/LipidPos/"):
    os.makedirs("graphs/LipidPos/")

#Loading data
r, z = np.genfromtxt("heads_r_pos_FullPlane.txt", unpack=True,dtype="float_")
#Need to remove lines, just have scatter points.
#Duplicate, and then merge into Half Plane:
rPos=abs(r) #make all r values positive.

#need to make the average line through middle. SPLIT THEN FIT to UPPER LEAF
MaxRadius=150 #won't fit to values with radius > 150
selection = np.where(rPos<=150)#gives element numbers of positions smaller than 150
fit=np.polyfit(rPos[selection],z[selection],2) #polynomial fit. Returns an array of coefficients.
def split(x):
	y=fit[0]*x**2+fit[1]*x+fit[2]
	return y
upperLeaf = np.where(z > split(r)) #binary array

#Defining sigmoid function to fit (use initial guess to improve match)
def sigmoid(x,x0,k,a,c): #the sigmoid curve maths. S(x)=1/(1+e^<-x>)
	y = a / (1 + np.exp(-k*(x-x0))) + c #1 doesnt need to be explicitly float
	return y #return y was missing. it would not provide anything back, being a useless NoneType!
	#that missing return brought a warning else where, so was difficult to find out!
#Fitting sigmoid upper leaf
initial_guess = [60,1e-2,100,130] #from Alexis
#for curve fit, need 1 row, many columns. or list
rCurve=np.ndarray.tolist(r[upperLeaf])
zCurve=np.ndarray.tolist(z[upperLeaf])
pOpt, pCov = curve_fit(sigmoid, rCurve, zCurve, p0=initial_guess)
#pOpt is parameters which minimise squared sum residuals. optimal parameters
#pCov is estimated covariance of fit

#PLOT: Full plane height vs radial distance
plt.figure(1)
plt.scatter(r,z,label="Full Plane (FP)")
plt.xlabel("Radial Distance / "+r"$\AA$")
plt.ylabel("Height / "+r"$\AA$")
plt.title("Curvature of Lipid Bilayer (Custom v0)")
plt.legend()
plt.show()
plt.savefig("graphs/LipidPos/G1_Full_Plane_Separate")

split=np.vectorize(split)#to allow running over each element in NDarray
sigmoid=np.vectorize(sigmoid)
#PLOT: half plane scatter (values)
plt.figure(2)
plt.scatter(rPos,z,label="Lipid Heads (HP)")
#PLOT: middle curve (parameters):
minR, maxR = 0, max(r) #find max radius, then plot the functions to this value.
points = int(1e4) #no. of points
SplitR = map(lambda x: float(maxR-minR)*x/points, range(points+1))#map returns a list. later convert to NDarray
#Range(x) makes a list of 0 to (x-1). Lambda is an anon. function

splitRnp=np.array(SplitR)#turning into arrays
SplitZ = split(splitRnp)
#PLOT: upper leaf curve (parameters): Sigmoid
ZUpper=sigmoid(splitRnp, pOpt[0],pOpt[1],pOpt[2],pOpt[3])#plotting the sigmoid fit
plt.plot(SplitR,ZUpper,label="Upper Leaf Fit (HP)")
plt.plot(SplitR, SplitZ, label="Midline Split Fit (HP)")

plt.xlabel("Radial Distance / "+r"$\AA$"); plt.ylabel("Height / "+r"$\AA$")
plt.title("Curvature of Lipid Bilayer (Custom v0)")
plt.legend(); plt.show()
plt.savefig("graphs/LipidPos/G2_Half_Plane_SetSeparate") #includes 3 half plane plots

plt.figure(3) #refresh, to prevent hiding the first graph by the scatter.
plt.xlabel("Radial Distance / "+r"$\AA$"); plt.ylabel("Height / "+r"$\AA$");plt.title("Curvature of Lipid Bilayer (Custom v0)")
plt.scatter(r,z,label="Lipid Heads (FP)")
plt.plot(SplitR, SplitZ, label="Midline Split (HP)")
plt.plot(SplitR,ZUpper,label="Upper Leaf Fit (HP)")
plt.legend()
#-----Curvature Calculation------------------------------------------#
#1. Select region
crystalWidth=50-25; minSelect=60+25; #v1=50, v2=25, v3=15, v4=10 angstroms
maxSelect=minSelect+crystalWidth #min from folder name
zupperLeaf=z[upperLeaf]; rUpperLeaf=r[upperLeaf] #work on upper leaf only.
selection=np.where((rUpperLeaf>=minSelect) & (rUpperLeaf<=maxSelect)) #restricting radial distance region
rSelect=rUpperLeaf[selection]; zSelect=zupperLeaf[selection]
#2. Calculate curvature (single value/ not continuous) --------------Copied-----------------
def calc_R(rC, zC):#calculate the distance of each 2D points from the center (rC, zC)
	return ((rSelect-rC)**2 + (zSelect-zC)**2)**0.5
def f(c):
	#calculate the algebraic distance between the data points and the mean circle centered at c=(xc, yc)
	Ri = calc_R(*c) #what is the meaning of this. *c can be a set of arguments
	return Ri - Ri.mean()

center_estimate = rSelect.mean(), zSelect.mean() #estimate initial
center, ier = optimize.leastsq(f, center_estimate) #send estimate, and function in. Sum of squares of equations minimised.

rC_2, zC_2 = center #solutions
Ri = calc_R(rC_2, zC_2)
print("The curvature is "+str(Ri.mean()))
plt.scatter(rC_2, zC_2) #plotting circle center (Single point)
print("Circle center is ("+ str(rC_2)+", "+ str(zC_2)+")") #printing out circle center twice
plt.show(); plt.savefig("graphs/LipidPos/G3_Full_Set")
#--------------End of Copied-----------------
#GRAPH: Need to figure out how to do 1D heatmap. Can try np.expand_dims(), but doesnst look good on long arrays
#Subplot1: Presence (normalised #Lipids) against Radial Distance. 
#This plot is not useful? because more lipids in curved regions, since pack longer region because not horizontal
plt.figure(4) #Don't need to save this histogram.
binCount=50
plt.xlabel("Radial Distance / "+r"$\AA$"); plt.ylabel("Frequency")
g2counts,g2bins,g2bars=plt.hist(rUpperLeaf, bins=binCount, label="Gradient_6nm_v1")
binsMean=[0.5*(g2bins[i]+g2bins[i+1]) for i in range(len(g2counts))]
plt.savefig("graphs/LipidPos/G4_Frequency_vs_Position")